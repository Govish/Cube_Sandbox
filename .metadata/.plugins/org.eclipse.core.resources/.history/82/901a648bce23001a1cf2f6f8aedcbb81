#include "stusb4500.h"
#include "stusb_regdefs.h"

HAL_StatusTypeDef pd_init() {
	HAL_StatusTypeDef status;

	//read the deviceID, make sure it's 0x21 or 0x25
	uint8_t buf;
	status = i2c_read_reg(STUSB_ADDR, DEVICE_ID_REG, &buf);
	if(buf != 0x21 || buf != 0x25) return HAL_ERROR;	//return error if we don't get an expected deviceID
	if(status != HAL_OK) return status;

	/*
	 * unmask the:
	 * 	PRT_STATUS_AL_MASK (bit 1)
	 * 	PD_TYPEC_STATUS_AL_MASK (bit 3)
	 * 	CC_DETECTION_STATUS_AL_MASK (bit 6) typo in datasheet
	 * 	HARD_RESET_AL_MASK (bit 7)
	 * 	in the ALERT_STATUS_1_MASK register
	 */
	Alt_S1Reg_Map alt_sreg_mask;
	alt_sreg_mask.data = 0xFF; //mask everything at the start
	alt_sreg_mask.map.prt_mask = 0;
	alt_sreg_mask.map.tcstat_mask = 0;
	alt_sreg_mask.map.ccdetect_mask = 0;
	alt_sreg_mask.map.hreset_mask = 0;
	status = i2c_write_reg(STUSB_ADDR, ALERT_STATUS_1_MASK_REG, alt_sreg_mask.data);
	if(status != HAL_OK) return status;

	//read 12 bytes starting at 0x0B (the ALERT_STATUS_1_REG buffer)
	//not 100% sure why we have to do this but the sample code does this?
	uint8_t throwaway[12];
	return i2c_read_regs(STUSB_ADDR, ALERT_STATUS_1_REG, 12, &throwaway);
}

HAL_StatusTypeDef pd_soft_reset() {
	HAL_StatusTypeDef status;

	//write '1' to the LSB of the RESET_CTRL_REGISTER
	status = i2c_write_reg(STUSB_ADDR, RESET_CTRL_REG, 0x01);
	if(status != HAL_OK) return status;

	//read the 12 bytes starting at the ALERT_STATUS_1 register again (not sure why but¯\_(ツ)_/¯)
	uint8_t throwaway[12];
	status = i2c_read_regs(STUSB_ADDR, ALERT_STATUS_1_REG, 12, &throwaway);
	if(status != HAL_OK) return status;

	//wait like 25ish milliseconds according to the sample code
	HAL_Delay(25);

	//write '0' to the LSB of the RESET_CTRL_REGISTER
	return i2c_write_reg(STUSB_ADDR, RESET_CTRL_REG, 0x00);
}

HAL_StatusTypeDef pd_send_soft_reset() {
	HAL_StatusTypeDef status;

	//dude like this entire "methodology" isn't in the datasheet and uses "ghost" registers lol
	//like none of these registers are in the datasheet
	//but just following what the sample code is doingggggg

	//send 0x0D to the TX_HEADER register (x51, not in the datasheet)
	status = i2c_write_reg(STUSB_ADDR, TX_HEADER_REG, 0x0D);
	if(status != HAL_OK) return status;

	//send 0x26 to the STUSB_GEN1S_CMD_CTRL register (x1A, not in the datasheet)
	return i2c_write_regs(STUSB_ADDR, STUSB_GEN1S_CMD_CTRL_REG, 0x26);
}

HAL_StatusTypeDef pd_read_sink_pdos(uint8_t* num_pdos, uint32_t* pdos) {
	HAL_StatusTypeDef status;

	//read from DPM_PDO_NUMB register (0x70) to find the number of PDO's available
	//just remember to dereference the pointer to num_pdos correctly!
	status = i2c_read_reg(STUSB_ADDR, DPM_PDO_NUMB_REG, num_pdos);
	if(status != HAL_OK) return status;
	*num_pdos &= 0x07; //mask only the bottom three bits

	//had some sort of read error if this number of PDOs we read is out of the expected range
	if(*num_pdos > 3 || *num_pdos < 1) return HAL_ERROR;

	//depending on the number of pdo's we have, read that many bytes x4 from the PDO registers
	//we're gonna have to do some weird concatenation scheme from the buffers though before returning them
	uint8_t pdo_data[*num_pdos << 2];
	status = i2c_read_regs(STUSB_ADDR, DPM_SNK_PDO1, *num_pdos << 2, &pdo_data);
	if(status != HAL_OK) return status;

	//time to reformat all the data we read from the registers

	/*
	void read_sink_pdo() {
	    I think this has to deal with the number of _SINK_ PDO's programmed into the device
	    read the number of PDO's available by reading from DPM_PDO_NUMB (0x70)
	        there can be any number of them between 0 and 3
	    depending on how many there are, read the PDO messages
	        start at DPM_SNK_PDO1 (0x85)
	        each message is 4 bytes
	        read upto 3 PDO's
	}
	*/
}

HAL_StatusTypeDef pd_read_rdo(uint32_t* rdo);	//read the currently active RDO /*TODO change the type of the pointer to a PDO struct*/

HAL_StatusTypeDef pd_update_num_pdos(uin8_t* num_active_pdos);	//set the number of active PDOs (1-3, values will be constrained)

HAL_StatusTypeDef pd_typec_info(CC_Reg_Map* infobuf);	//call this to read the CC_STATUS_REGISTER; will have to decipher using struct encodings

HAL_StatusTypeDef pd_request_pdo_num(uint8_t pdo_index);	//call this to negotiate for a particular PDO in the received PDOs

HAL_StatusTypeDef pd_auto_nego(float* voltage, float* current, float* power);	//call this to automatically negotiate a contract
																				//type C device must be attached for nego to be successful

